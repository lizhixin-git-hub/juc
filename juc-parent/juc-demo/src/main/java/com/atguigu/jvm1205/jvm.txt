1、JVM(java虚拟机)是运行在操作系统之上的，它与硬件没有直接的交互。
2、类装载器ClassLoader（相当于快递员）:负责加载class文件，class文件在文件开头有特定的文件标示，将class文件
字节码内容加载到内存中，并将这些内容转换成方法区（存放类模板）中的运行时数据结构并且ClassLoader只负责class
文件的加载，至于它是否可以运行，则由Execution Engine（执行引擎）决定。
class（car.class）文件--》ClassLoader(Car Class)加载进JVM方法区，形成类的模板--》getClass()实例化成实例对象
[模板只有一个，实例有多个]
3、class文件能加载进JVM,不光只是.class的后缀名，在文件开头有特定的文件标示（cafe babe）。
4、虚拟机自带的加载器（顺序Bootstrap->Extension->AppClassLoader）jre->lib->rt.jar：
启动类（根）加载器（Bootstrap），由C++语言编写，
Object object = new Object();
//打印出null,下面代码相当于找到getClass()类模板，getClassLoader()找到类模板的类加载器
//由于Object类是JDK自带，是一切类的祖类，故打印Bootstrap(C++编写)加载器为null。
System.out.println(object.getClass().(getClassLoader));
扩展类加载器（Extension,java语言编写）：JDK中javax包中类，jre->lib->ext(.jar)
应用程序加载器（AppClassLoader,自定义的类）
MyObject myObject = new MyObject();
//打印出sun.misc.Launcher$AppClassLoader,下面代码相当于找到getClass()类模板，getClassLoader()找到类模板的类加载器
//由于MyObject类是自定义，故打印应用程序加载器为sun.misc.Launcher$AppClassLoader。
System.out.println(myObject.getClass().getClassLoader());
java也叫系统类加载器，加载当前应用的classpath的所有类。
用户自定义加载器：java.lang.ClassLoader的子类，用户可以定制类的加载方式：
自定义类继承ClassLoader抽象类

双亲委派：
当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成
每一尝个层次类加载器都是如此，因此所有的家在请求都应该传送到启动加载器中，只有当父类加载器
反馈自己无法完成这个请求的时候(在它的加载路径下没有找到所需要加载的Class)，子类加载器才会
试自己去加载。
采用双亲委派机制的一个好处是比如加载位于rt.jar包中的类java.lang.Object,不管是哪个加载器
加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终
得到的都是同样一个Object对象。

Native Interface本地接口：
本地接口的作用是融合不同的编程语言为java所用，它的初衷是融合C/C++程序，Java诞生的时候
是C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理
标记为native的代码，它的具体做法是Native Method Stack中登记native，在Execution Engine
执行时加载native libraies。
目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统
管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket
通信，也可以使用Web Service等等

Native Method Stack（本地方法栈）：
它的具体做法是Native Method Stack中登记Native方法，在Execution Engine执行时加载本地方法库。

程序计数器（PC寄存器）：
每一个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码(用来存储
指向下一条指令的地址，也即将要执行的指令代码)，由执行引擎读取下一条指令，是一个非常小的内存空间
几乎可以忽略不计。
这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来
选取下一条需要执行的字节码指令。
如果执行的是一个Native方法，那这个计数器是空的。
用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出（OutOfMemory=OOM）错误。

Method Area（方法区）：
供各线程共享的运行时内存区域。它存储了每个类的结构信息，例如运行时常量池（Runtime Constant Pool）
、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的是规范，在不同的虚拟机里头实现实不一样的，最典型的就是永久
代（PermGen space）和元空间（Metaspace）。
但是，实例变量存在堆内存中，和方法区无关。

java栈：
栈管运行，堆管存储。栈最多的是装在方法，随线程开始而开始，结束而结束。
栈也叫内存栈，主管java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命期，线程结束
栈内存也就释放，对于栈来说不存在垃圾回收的问题，只要线程一结束该栈Over，生命周期和线程一致，是线程
私有。8中基本类型的变量+对象的引用变量+实例方法都是在函数的栈内存中分配。
栈存储什么？
栈帧（就是方法）中主要保存3中数据：
本地变量（Local Variables）:输入参数和输出参数以及方法内的变量；
栈操作（Operand Stack）：记录出栈、入栈的操作，类似于程序计数器（PC寄存器）；
栈帧数据（Frame Data）：包括类文件、方法等。
栈运行原理：
栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关
方法（Method）和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法
又调用了B方法，于是产生栈帧F2,，也被压入栈，B方法又调用了C方法，于是产生栈帧F3，也被压入栈，....
执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧....
遵循“先进后出/后进先出”原则
每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个
方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程，栈的大小和具体JVM的实现无关
通常在256K~756K之间，与等于1MB左右。
HotSpot是使用指针的方式来访问对象
Java堆中存放访问类元数据（类模板）的地址
reference存储的就直接是对象的地址

堆（Heap）：
新生代(new)：伊甸园区（Eden Space）、幸存者0区(Survivor 0 Space)、幸存者1区(Survivor 1 Space)
老年代
元空间（永久代）
一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量
放到堆内存中，保存所有应用类型的真实信息，以方便执行器执行，堆内存分为三部分：
Young Generation Space 新生区（8:1:1）：Young/New
Tenure Generation Space 养老区：Old/Tenure
Permanent Space 永久区(java8为元空间)：Perm
堆内存逻辑上分为三部分：新生+养老+永久
物理上两部分：新生+养老（1:2）
新生区：
新生区是类的诞生、成长、消亡的区域，一个类在这里产生，应用，最后被垃圾回收器收集，结束生命。新生区
又分为两部分：伊甸园区（Eden Space）和幸存区（Survivor Space），所有的类都是在伊甸园区被new出来的。
幸存区有两个：0区（Survivor 0 Space）from和1区（Survivor 1 Space）to。当伊甸园区的空间用完时，程序又
需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（Minor GC），将伊甸园区中的不在被其他对象所
引用的对象进行销毁。然后将伊甸园区中的剩余对象移动到幸存0区。若幸存0区也满了，再对该区进行垃圾回收，
然后移动到1区。那如果1区也满了呢？再移动到养老区。若养老区也满了，那么这个时候将产生Major GC(Full GC),
进行养老区的内存清理。若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。
如果出现java.lang.OutOfMemoryError:java heap space异常，说明java虚拟机的堆内存不够。原因有二：
（1）java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。
（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。
MinorGC的过程：（复制->清空->互换）：
1：Eden、SurvivorFrom复制到SurvivorTo,年龄1
首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC的时候会扫描Eden区
和From区域，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域（如果有对象的年龄已经达到了老年
的标准，则赋值到老年代），同时把这些对象的年龄+1。
2：清空Eden、SurvivorFrom
然后，清空Eden和SurvivorFrom中的对象，也即复制之后交换，谁空谁是To
3、SurvivorTo和SurvivorFrom互换：
最后，SurvivorTo和SurvivorFrom互换，原SurvivorTo成为了下一次GC时的SurvivorFrom区。部分对象会在From和To区域中
复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认是15），最终如果还是存活，就存入到老年代。
实际而言，方法区（Method Area）和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通变量+静态变量+编译器
编译后的代码等等，虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-leap（非堆），母的就是要和堆分开。
对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代（Permanent Gen）”,但严格本质上说两者不同，或者说使用永久代来实现
方法区而已，永久代是方法区（相当于是一个接口interface）的一个实现，jdk1.7的版本中，已经将原本放在永久代中的字符串常量池移走。
永久区（java7之前有）：
永久存储区域是一个常驻内存区域，用于存放JDK自身携带的Class，Interface的元数据，也就是说它存储的是运行环境必须的类信息，被装载
进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占用的内存。
在Java8中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。
元空间与永久代之间最大的区别在于：
永久代使用的JVM堆内存，但是Java8以后的元空间并不在虚拟机中，而是使用本机物理内存。
因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入native memory，字符串池和类的静态变量放入Java堆中，这样可以
加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。
堆内存调优：
-Xms设置初始分配大小，默认为物理内存的“1/64”
-Xmx最大分配内存，默认为物理内存的“1/4”
-XX:PrintGCDetails:输出详细的处理日志
-Xms10m -Xmx10m -XX:+PrintGCDetails
public static void main(String[] args){
   long maxMemory = RunTime.getRuntime().maxMemory();//返回Java虚拟机试图使用的最大内存量
   long totalMemory = RunTime.getRuntime().totalMemory();//返回Java虚拟机中的内存总量
   System.out.println("MAX_MEMORY=" + maxMemory + "字节、" +
   (MaxMemory / (double)1024/1024) + "MB");
   System.out.println("TOTAL_MEMORY=" + totalMemory + "字节、" +
   (totalMemory / (double)1024/1024) + "MB");
}

GC是什么（分代收集算法）：
次数上频繁收集Young区
次数上较少收集Old区
基本不动Perm区（元空间）
GC4大算法：
JVM在进行GC时，并非每次都对上面的三个内存区域一起回收，大部分时候回收的都是指新生代。
因此GC按照回收的区域有分了两种类型，一种是普通GC（Minor GC），一种是全局GC（Major GC Or Full GC）
Minor GC 和 Full GC的区别：
普通GC（Minor GC）：只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，
所以Minor GC非常频繁，一般回收速度也比较快。
全局GC（Major GC Or Full GC）：只发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（
但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上（Full GC全区扫描的范围更大）。
4大算法：
1、引用计数法（JVM的实现一般不采用这种算法）：
缺点：
每次对对象赋值时均要维护引用计数器，且计数器本身也有一定的消耗
较难处理循环引用
public static void main(String[] agrs){
    RefCountGC objectA = new RefCountGC();
    RefCountGC objectB = new RefCountGC();
    //循环引用
    objectA.instance = objectB;
    objectB.instance = objectA;
    objectA = null;
    objectB = null;
    System.gc();
}
2、复制算法（年轻代Copying）
年轻代中使用的是Minor GC，这种GC算法采用的是复制算法（Copying）
原理：
从根集合（GC Root）开始，通过tracing从From中找到存活对象，拷贝到To中；From到To交换身份，
下次内存分配从To开始。复制算法不会产生内存碎片。
优点：
没有标记和清除的过程，效率高
没有内存碎片，可以利用bump-the-pointer实现快速内存分配
缺点：
它浪费了一半的内存，这太要命了
如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有的
引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。所以从以上描述
不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要是，我们必须要克服50%内存的浪费。
3、标记清楚（Mark-Sweep）
老年代一般是由标记清除或者是标记清除与标记整理混合
原理：
算法分成标记和清除两个阶段，先标记出要回收的对象，然后统一回收这些对象。
优点：
不需要额外的空间
缺点：
首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲
其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落
的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销，
而且在分配对象的时候，寻找连续的内存空间会不太好找。
用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽，GC线程就会被触发并将程序暂停，
随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。
4、标记压缩\整理（Mark-Compact）：
老年代一般是由标记清除或者是标记清除与标记整理混合
原理：
标记（与标记清除一样）
压缩（再次扫描，并往一端滑动存活对象）
优点：
没有内存碎片，可以利用bump-the-pointer
缺点：
标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活的对象，还要整理所有存活对象的引用地址。
从效率上来说，标记/整理算法要低于复制算法
总结：
没有最好的算法，只有最合适的算法（采用分代收集算法）
内存效率：复制算法>标记清除算法>标记整理算法(此处的效率只是简单的对比时间的复杂度，实际情况不一定如此)
内存整齐度：复制算法>标记整理算法>标记清除算法
内存利用率：标记整理算法=标记清除算法>复制算法
可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多的内存，而为了尽量兼顾上面所提到的三个指标，
标记/整理算法相对来说更平滑一些，但效率上依然不尽人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理
内存的过程，java9用到了GE收集算法。
年轻代：
年轻代特点是区域相对老年代较小，对象存活率低
这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因而很适合用于年轻代的回收。
而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
老年代：
老年代的特点是区域较大，对象存活率高
这种情况，存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记清楚或者标记清除与标记整理的混合实现。
Mark阶段的开销与存活对象的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程
利用，对并发、并行的形式提标记效率。
Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点，回收的过程没有对象的移动。使其相对其他有对象
移动的步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。